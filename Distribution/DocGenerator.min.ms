/*! © 2022 imaoki | MIT License | https://github.com/imaoki */;(local hasMetRequirements;fn hasMetRequirements = (isStruct ::std and isProperty ::std #StructName and classOf ::std.StructName == MAXScriptFunction and ::std.StructName() == #StandardStruct and isStructDef ::ParserCombinatorStruct and isProperty ::ParserCombinatorStruct #StructName and classOf ::ParserCombinatorStruct.StructName == MAXScriptFunction and ::ParserCombinatorStruct.StructName() == #ParserCombinatorStruct and isStructDef ::MarkdownStruct and isProperty ::MarkdownStruct #StructName and classOf ::MarkdownStruct.StructName == MAXScriptFunction and ::MarkdownStruct.StructName() == #MarkdownStruct;);if not hasMetRequirements() do (local fileClass = DotNetClass "System.IO.File";local pathClass = DotNetClass "System.IO.Path";local currentDir = pathClass.GetDirectoryName (getSourceFileName());local standardFile = currentDir + @"\Standard.min.ms";local parserCombinatorFile = currentDir + @"\ParserCombinator.min.ms";local markdownFile = currentDir + @"\Markdown.min.ms";if fileClass.Exists standardFile do fileIn standardFile;if fileClass.Exists parserCombinatorFile do fileIn parserCombinatorFile;if fileClass.Exists markdownFile do fileIn markdownFile;);if not hasMetRequirements() do (format "[error]Requirement not met.\n";);ok;);global docGeneratorDefinitionPool = Dictionary #String;::docGeneratorDefinitionPool[@"DocDependentTable.ms"] = struct DocDependentTableStruct (private declarationTable,private dependentTable,public fn AddDependent astNode path = (if this.isAstNode astNode and astNode.Type == #DocDependent do (for n in astNode.Value where this.isAstNode n do (if n.Type == #GlobalVarName then (local key = path.Source;if not hasDictValue this.dependentTable key do (this.dependentTable[key] = #(););appendIfUnique this.dependentTable[key] n.Value;);else (local key = n.Value.Value;if not hasDictValue this.declarationTable key do (this.declarationTable[key] = #(););appendIfUnique this.declarationTable[key] path;););for key in this.declarationTable.Keys do (qsort this.declarationTable[key] ::std.Comparer.CompareProperty propName:#Source;);for key in this.dependentTable.Keys do (qsort this.dependentTable[key] ::std.Comparer.CompareStringLogical;););ok;),public fn GetDependent path = (local dependent = DataPair VarName:#() Path:#();local key = path.Source;if hasDictValue this.dependentTable key do (dependent.VarName = deepCopy this.dependentTable[key];dependent.Path = for key in dependent.VarName collect (if hasDictValue this.declarationTable key then (deepCopy this.declarationTable[key];);else (#(););););dependent;),public fn Initialize = (this.declarationTable = Dictionary #String;this.dependentTable = Dictionary #String;ok;),private fn isAstNode obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #AstNodeStruct;),public fn StructName = #DocDependentTableStruct,public fn Dump indent:"" out:listener = (format "%DocDependentTableStruct\n" indent to:out;format "%  declarationTable:%\n" indent this.declarationTable.Count to:out;for key in this.declarationTable.Keys do (local v = this.declarationTable[key];format "%    [\"%\"]:%\n" indent key v.Count to:out;for i = 1 to v.Count do (format "%      [%]:\n" indent i to:out;format "%             Source:@\"%\"\n" indent (::std.StringUtility.EscapeBackslash v[i].Source) to:out;format "%        Destination:@\"%\"\n" indent (::std.StringUtility.EscapeBackslash v[i].Destination) to:out;););format "%  dependentTable:%\n" indent this.dependentTable.Count to:out;for key in this.dependentTable.Keys do (local v = this.dependentTable[key];format "%    [\"%\"]:%\n" indent (::std.StringUtility.EscapeBackslash key) v.Count to:out;for i = 1 to v.Count do (format "%      [%]:@\"%\"\n" indent i v[i] to:out;););ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.Initialize();););::docGeneratorDefinitionPool[@"DocOptions.ms"] = struct DocOptionsStruct (public BasePath = @"..\",public DateFormat = "yyyy-MM-dd",public DotNetApiBaseUrl = "https://docs.microsoft.com/ja-jp/dotnet/api/",public DotNetApiVersion = "netframework-4.8",public EncodingBom = false,public EncodingName = "utf-8",public FileNameSeparator = "-",public SaveDirectoryName = "Document",public ShowError = false,public SiteTitle = "mxsdoc",public SiteUrl = "index.html",public TemplatePath = @".\DocGenerator.Template\default-template.html",public fn StructName = #DocOptionsStruct,public fn Dump indent:"" out:listener = (format "%DocOptionsStruct\n" indent to:out;format "%  BasePath:@\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.basePath) to:out;format "%  DateFormat:\"%\"\n" indent this.DateFormat to:out;format "%  DotNetApiBaseUrl:\"%\"\n" indent this.DotNetApiBaseUrl to:out;format "%  DotNetApiVersion:\"%\"\n" indent this.DotNetApiVersion to:out;format "%  EncodingBom:%\n" indent this.EncodingBom to:out;format "%  EncodingName:\"%\"\n" indent this.EncodingName to:out;format "%  FileNameSeparator:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.FileNameSeparator) to:out;format "%  SaveDirectoryName:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.SaveDirectoryName) to:out;format "%  ShowError:%\n" indent this.ShowError to:out;format "%  SiteTitle:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.SiteTitle) to:out;format "%  SiteUrl:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.SiteUrl) to:out;format "%  TemplatePath:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.TemplatePath) to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::docGeneratorDefinitionPool[@"DocPathMaker.ms"] = struct DocPathMakerStruct (public Options,private pathUtility,private uriClass = DotNetClass "System.Uri",public fn FromDirectory dir recursive:false ignore: exception: = (if classOf ignore == String do (ignore = #(ignore););if classOf exception == String do (exception = #(exception););dir = this.trimEndBackslash dir;local files = ::std.FileUtility.GetFiles dir "*.ms" recursive:recursive;for file in files collect (local shouldCollect = true;if classOf ignore == Array do (shouldCollect = not this.matchPatterns file ignore;if not shouldCollect and classOf exception == Array do (shouldCollect = this.matchPatterns file exception;););if shouldCollect then (this.FromFile file;);else (dontCollect;););),public fn FromFile file = (local absBasePath = this.GetAbsoluteBasePath();local baseUri = DotNetObject this.uriClass (absBasePath + @"\");local destUri = DotNetObject this.uriClass file;local relativeUri = baseUri.MakeRelativeUri destUri;local relativePath = relativeUri.ToString();relativePath = substituteString relativePath "/" this.Options.FileNameSeparator;local destinationPath = absBasePath + @"\" + this.Options.SaveDirectoryName + @"\" + (toLower relativePath);destinationPath = this.pathUtility.ChangeExtension destinationPath "html";DataPair Source:file Destination:destinationPath;),public fn GetAbsoluteBasePath = (this.trimEndBackslash (this.pathUtility.GetFullPath this.Options.BasePath);),public fn GetAbsoluteIndexPath = (this.GetAbsoluteBasePath() + @"\" + this.Options.SaveDirectoryName + @"\" + this.Options.SiteUrl;),public fn GetAbsoluteTemplatePath = (this.pathUtility.GetFullPath this.Options.TemplatePath;),private fn isDocOptions obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #DocOptionsStruct;),private fn matchPatterns input patterns = (local isMatch = false;for pattern in patterns while not isMatch do (isMatch = matchPattern input pattern:pattern ignoreCase:true;);isMatch;),private fn trimEndBackslash input = (if matchPattern input pattern:@"*\" then (::std.StringUtility.TrimEnd input @"\";);else (input;);),public fn StructName = #DocPathMakerStruct,public fn Dump indent:"" out:listener = (format "%DocPathMakerStruct\n" indent to:out;format "%  Options:\n" indent to:out;this.Options.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (if not this.isDocOptions this.Options do (this.Options = (::docGeneratorDefinitionPool[@"DocOptions.ms"])(););this.pathUtility = ::std.PathUtilityStruct (getSourceFileName());););::docGeneratorDefinitionPool[@"DocRender.ms"] = struct DocRenderStruct (public Options,private template = "",private toc,private defaultTemplate = "<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>{{{site.title}}}</title>\n</head>\n<body>\n<h1><a href=\"{{{site.url}}}\">{{{site.title}}}</a></h1>\n<h2>{{{doc.title}}}</h2>\n{{{doc.toc}}}\n{{{doc.content}}}\n</body>\n</html>\n",private markdown,private pathUtility,private spaceRegex,private uriClass = DotNetClass "System.Uri",public fn Render astNode docTitle:"Untitled" dependent: = (this.template = this.readTemplate();this.toc = StringStream "";local docContent = StringStream "";format "%" (this.dependentToHtml dependent) to:docContent;format "%" (::std.StringUtility.Trim (this.docToHtml astNode 3 dependent);) to:docContent;docContent = docContent as String;this.toc = this.toc as String;local html = copy this.template;html = substituteString html "{{{site.title}}}" (this.sanitize this.Options.SiteTitle);html = substituteString html "{{{site.url}}}" (this.sanitize this.Options.SiteUrl);html = substituteString html "{{{doc.title}}}" (this.sanitize docTitle);html = substituteString html "{{{doc.toc}}}" this.toc;html = substituteString html "{{{doc.update}}}" (this.generateNowDate());html = substituteString html "{{{doc.content}}}" docContent;html;),public fn RenderIndex docContent = (this.template = this.readTemplate();local html = copy this.template;html = substituteString html "{{{site.title}}}" (this.sanitize this.Options.SiteTitle);html = substituteString html "{{{site.url}}}" (this.sanitize this.Options.SiteUrl);html = substituteString html "{{{doc.title}}}" "Index";html = substituteString html "{{{doc.toc}}}" "";html = substituteString html "{{{doc.update}}}" (this.generateNowDate());html = substituteString html "{{{doc.content}}}" docContent;html;),private fn adjustIndent input indent:"  " = (local indentCount = 0;local indentValue = undefined;local lines = ::std.StringUtility.Split input "\n" removeEmpty:false;for s in lines do (local space = (this.spaceRegex.Match s).Value;local spaceCount = space.Count;if spaceCount > 0 do (if indentValue == undefined or spaceCount < indentCount do (indentCount = spaceCount;indentValue = space;);););if classOf indentValue == String then (local result = "";local lineCount = lines.Count;for i = 1 to lineCount do (local s = lines[i];local delimiter = if i == lineCount then "" else "\n";local fromIndex = findString s indentValue;if classOf fromIndex == Integer then (result += (replace s fromIndex indentCount indent) + delimiter;);else (result += s + delimiter;););result;);else (input;);),private fn dependentToHtml dependent = (local out = StringStream "";if this.isValidDependent dependent do (local absBasePath = this.pathUtility.GetFullPath this.Options.BasePath;format "<dl><dt>依存</dt><dd><ul>\n" to:out;for i = 1 to dependent.VarName.Count do (format "<li>" to:out;local varName = this.sanitize dependent.VarName[i];local path = dependent.Path[i];if path.Count == 1 then (local url = this.pathUtility.GetFileName path[1].Destination;format "<code><a href=\"%\">%</a></code>" url varName to:out;);else (format "<code>%</code><ul>\n" varName to:out;for i = 1 to path.Count do (local url = this.pathUtility.GetFileName path[i].Destination;local fileName = substituteString path[i].Source absBasePath "";fileName = this.sanitize fileName;format "<li><a href=\"%\">%</a></li>\n" url fileName to:out;);format "</ul>" to:out;);format "</li>\n" to:out;);format "</ul></dd></dl>\n" to:out;);out as String;),private fn docCommentToHtml n dependent = (local out = StringStream "";if this.isAstNode n do (case n.Type of ((#AccessorDef): (for v in n.Value do (local isClssForm = v.Type == #ClassForm;if isClssForm do format "[" to:out;format "%" (this.docCommentToHtml v dependent) to:out;if isClssForm do format "]" to:out;););(#ClassDef): (local dotNetClassKeys = #("dotnetclass","dotnetcontrol","dotnetobject";);local isDotNetClassDef = false;for v in n.Value do (local html = this.docCommentToHtml v dependent;if v.Type == #VarName do (isDotNetClassDef = findItem dotNetClassKeys (toLower html););if v.Type == #ClassName do format ":" to:out;if isDotNetClassDef and v.Type == #ClassName then (local url = copy this.Options.DotNetApiBaseUrl;url += toLower html;url += "?view=" + this.Options.DotNetApiVersion;format "<a href=\"%\">%</a>" url html to:out;);else (format "%" html to:out;);););(#ClassForm): (format "&lt;" to:out;local html = for v in n.Value collect (this.docCommentToHtml v dependent;);html = ::std.StringUtility.Join html separator:"|";format "%" html to:out;format "&gt;" to:out;);(#ClassName): (local html = for v in n.Value collect (this.docCommentToHtml v dependent;);html = ::std.StringUtility.Join html separator:".";format "%" html to:out;);(#ConstructorDef): (for v in n.Value do (if v.Type != #VarName do format "&nbsp;" to:out;format "%" (this.docCommentToHtml v dependent) to:out;););(#DocComment): (for v in n.Value do (format "%" (this.docCommentToHtml v dependent) to:out;););(#KeywordParameter): (for v in n.Value do (if v.Type == #ClassForm do format ":" to:out;format "%" (this.docCommentToHtml v dependent) to:out;););(#ParamName): (for v in n.Value do (if this.isAstNode v then (format "%" (this.docCommentToHtml v dependent) to:out;);else (format "%" (this.sanitize v) to:out;);););(#PositionalParameter): (format "%" (this.docCommentToHtml n.Value dependent) to:out;);(#Tag): (format "<dl>\n" to:out;for v in n.Value do (case v.Type of ((#TagType): format "<dt>" to:out;(#Text): format "<dd>" to:out;default: format "<dd><code>" to:out;);format "%" (this.docCommentToHtml v dependent) to:out;case v.Type of ((#TagType): format "</dt>\n" to:out;(#Text): format "</dd>\n" to:out;default: format "</code></dd>\n" to:out;););format "</dl>\n" to:out;);(#TagType): (local html = case n.Value of ((#Param): "パラメータ";(#Prop): "プロパティ";(#Remarks): "補足";(#Returns): "戻り値";(#Var): "変数";default: "タグ";);format "%" html to:out;);(#Text): (local markdownText = this.adjustIndent n.Value;if this.isValidMarkdown this.markdown then (format "%" (this.markdown.ToHtml markdownText) to:out;);else (format "<pre class=\"markdown\"><code class=\"language-markdown\">" to:out;format "%" (this.sanitize markdownText) to:out;format "</code></pre>\n" to:out;););(#VarName): (local absBasePath = this.pathUtility.GetFullPath this.Options.BasePath;for v in n.Value do (local varNameIndex = 0;if this.isValidDependent dependent do (varNameIndex = findItem dependent.VarName v;if varNameIndex > 0 do (if dependent.Path[varNameIndex].Count != 1 do (varNameIndex = 0;);););if varNameIndex == 0 then (format "%" (this.sanitize v) to:out;);else (local varName = this.sanitize dependent.VarName[varNameIndex];local path = dependent.Path[varNameIndex];local url = this.pathUtility.GetFileName path[1].Destination;format "<a href=\"%\">%</a>" url varName to:out;);););default: ();););out as String;),private fn docToHtml n h dependent = (local out = StringStream "";if this.isAstNode n do (case n.Type of ((#DocSeq): (format "<li>" to:toc;for i = 1 to n.Value.Count do (this.writeTocBorderTag n i;format "%" (this.docToHtml n.Value[i] (h + 1) dependent) to:out;this.writeTocEndTag n i;);format "</li>" to:toc;);(#Document): (format "<div class=\"table-of-contents\"><ul><li>" to:toc;for i = 1 to n.Value.Count do (this.writeTocBorderTag n i;format "%" (this.docToHtml n.Value[i] h dependent) to:out;this.writeTocEndTag n i;);format "</li></ul></div>" to:toc;);(#SimpleDoc): (local headerText = "";if n.Value[2].Type == #Keywords do (local keywordsNode = n.Value[2];for i = 1 to keywordsNode.Value.Count do (local delimiter = if i == 1 then "" else " ";headerText += delimiter + keywordsNode.Value[i].Value;););local childCount = n.Value.Count;local varNameDelimiter = if childCount == 2 then "" else " ";local varNameText = n.Value[childCount].Value;headerText += varNameDelimiter + varNameText;local headerId = this.uriClass.EscapeUriString (toLower varNameText);format "<a href=\"#%\">%</a>" headerId (this.sanitize varNameText) to:toc;format "<h% id=\"%\">%</h%>\n" h headerId (this.sanitize headerText) h to:out;format "%" (this.docCommentToHtml n.Value[1] dependent) to:out;);default: ();););out as String;),private fn generateNowDate = ((DotNetClass "System.DateTime").Now.ToString this.Options.DateFormat;),private fn isAstNode obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #AstNodeStruct;),private fn isDocOptions obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #DocOptionsStruct;),private fn isValidDependent obj = (classOf obj == DataPair and isProperty obj #VarName and isProperty obj #Path and classOf obj.VarName == Array and classOf obj.Path == Array and obj.VarName.Count > 0 and obj.VarName.Count == obj.Path.Count;),private fn isValidMarkdown obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #MarkdownStruct;),private fn readTemplate = (local code = ::std.FileUtility.ReadAllText (this.pathUtility.GetFullPath this.Options.TemplatePath;);if classOf code == String and code.Count > 0 then (code;);else (copy this.defaultTemplate;);),private fn sanitize input = (substituteString (substituteString (substituteString (substituteString (substituteString input "&" "&amp;";) "\"" "&quot;";) "<" "&lt;";) ">" "&gt;";) " " "&nbsp;";),private fn writeTocBorderTag n i = (local curType = n.Value[i].Type;if i == 1 then (if curType == #DocSeq do (format "<ul>" to:this.toc;););else (local preType = n.Value[i - 1].Type;case preType of ((#DocSeq): (case curType of ((#DocSeq): format "</ul><ul>" to:this.toc;(#SimpleDoc): format "</ul></li><li>" to:this.toc;default: ();););(#SimpleDoc): (case curType of ((#DocSeq): format "<ul>" to:this.toc;(#SimpleDoc): format "</li><li>" to:this.toc;default: ();););default: ();););ok;),private fn writeTocEndTag n i = (if i == n.Value.Count and n.Value[i].Type == #DocSeq do (format "</ul>" to:this.toc;);ok;),public fn StructName = #DocRenderStruct,public fn Dump indent:"" out:listener = (format "%DocRenderStruct\n" indent to:out;format "%  Options:\n" indent to:out;this.Options.Dump indent:(indent + "    ") out:out;format "%  defaultTemplate:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.defaultTemplate) to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (if not this.isDocOptions this.Options do (this.Options = (::docGeneratorDefinitionPool[@"DocOptions.ms"])(););this.markdown = ::MarkdownStruct();this.pathUtility = ::std.PathUtilityStruct (getSourceFileName());this.spaceRegex = ::std.StringUtility.CreateRegex "^ +";););::docGeneratorDefinitionPool[@"Parser\DocComment.ms"] = struct DocCommentStruct (public ShowError = false,private parser,private pc,public fn GetParser = (this.parser;),public fn Parse input = (local context = this.pc.Context input;local result = this.parser.Parse context;if this.ShowError do context.PrintError result;result;),private fn program = (this.pc.Partial this.astNode #DocComment (this.pc.Flatten (this.pc.Sequence #(this.whitespace(),this.pc.Skip (this.start()),this.whitespace(),this.pc.Option (this.text()),this.pc.Option (this.tags()),this.whitespace(),this.pc.Skip (this.pc.Expect (this.end()) expected:"*/"););) depth:1;);),private fn tags = (this.pc.Flatten (this.pc.Many (this.pc.Sequence #(this.whitespace(),this.tag();););) depth:1;),private fn tag = (this.pc.Partial this.astNode #Tag (this.pc.Choice #(this.paramTag(),this.propTag(),this.returnsTag(),this.varTag(),this.remarksTag();););),private fn paramTag = (this.pc.Sequence #(this.tagTypeParam(),this.whitespace(),this.pc.Expect (this.paramName()) expected:"<param_name>",this.whitespace(),this.pc.Expect (this.classForm()) expected:"<class_form>",this.whitespace(),this.pc.Option (this.text()););),private fn propTag = (this.pc.Sequence #(this.tagTypeProp(),this.whitespace(),this.pc.Expect (this.classForm()) expected:"<class_form>",this.whitespace(),this.pc.Option (this.text()););),private fn returnsTag = (this.pc.Sequence #(this.tagTypeReturns(),this.whitespace(),this.pc.Expect (this.classForm()) expected:"<class_form>",this.whitespace(),this.pc.Option (this.text()););),private fn varTag = (this.pc.Sequence #(this.tagTypeVar(),this.whitespace(),this.pc.Expect (this.classForm()) expected:"<class_form>",this.whitespace(),this.pc.Option (this.text()););),private fn remarksTag = (this.pc.Sequence #(this.tagTypeRemarks(),this.whitespace(),this.pc.Option (this.text()););),private fn paramName = (this.pc.Partial this.astNode #ParamName (this.pc.Sequence #(this.varName(),this.pc.Option (this.pc.Char ":");););),private fn classForm = (this.pc.Partial this.astNode #ClassForm (this.pc.Flatten (this.pc.Sequence #(this.pc.Skip (this.pc.Char "<"),this.pc.Expect (this.pc.List (this.classDecl()) (this.pc.Char "|");) expected:"1 or more <class_decl>",this.pc.Skip (this.pc.Expect (this.pc.Char ">") expected:">"););) depth:1;);),private fn classDecl = (this.pc.Choice #(this.constructorDef(),this.accessorDef(),this.classDef(),this.className(););),private fn constructorDef = (this.pc.Partial this.astNode #ConstructorDef (this.pc.Flatten (this.pc.Sequence #(this.varName(),this.pc.Flatten (this.pc.Many (this.pc.Sequence #(this.whitespace(),this.pc.Choice #(this.positionalParameter(),this.keywordParameter();););) minCount:1;) depth:1;);) depth:1;);),private fn accessorDef = (this.pc.Partial this.astNode #AccessorDef (this.pc.Flatten (this.pc.Sequence #(this.varName(),this.pc.Skip (this.pc.Char "["),this.pc.Expect (this.pc.Delay this.classForm) expected:"<class_form>",this.pc.Skip (this.pc.Expect (this.pc.Char "]") expected:"]"););) depth:1;);),private fn classDef = (this.pc.Partial this.astNode #ClassDef (this.pc.Sequence #(this.varName(),this.pc.Skip (this.pc.Char ":"),this.pc.Expect (this.className()) expected:"<class_name>";););),private fn className = (this.pc.Partial this.astNode #ClassName (this.pc.List (this.varName()) (this.pc.Char "."););),private fn positionalParameter = (this.pc.Partial this.astNode #PositionalParameter (this.pc.Delay this.classForm;);),private fn keywordParameter = (this.pc.Partial this.astNode #KeywordParameter (this.pc.Flatten (this.pc.Sequence #(this.varName(),this.pc.Skip (this.pc.Char ":"),this.pc.Expect (this.pc.Delay this.classForm) expected:"<class_form>";);) depth:1;);),private fn varName = (this.pc.Partial this.astNode #VarName (this.pc.Sequence #(this.pc.Option (this.pc.Char "&"),this.pc.Choice #(this.identifier(),this.quotedName(););););),private fn text = (this.pc.Partial this.astNode #Text (this.pc.Map (this.pc.Join (this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.pc.Choice #(this.tagType(),this.end(););),this.pc.AnyChar(););););) this.trimText;);),private fn tagType = (this.pc.Choice #(this.tagTypeParam(),this.tagTypeProp(),this.tagTypeRemarks(),this.tagTypeReturns(),this.tagTypeVar(););),private fn tagTypeParam = (this.pc.Partial this.astNode #TagType (this.pc.Map (this.pc.Join (this.pc.Sequence #(this.tagTypeSymbol(), this.pc.Token "param"););) this.asName;);),private fn tagTypeProp = (this.pc.Partial this.astNode #TagType (this.pc.Map (this.pc.Join (this.pc.Sequence #(this.tagTypeSymbol(), this.pc.Token "prop"););) this.asName;);),private fn tagTypeRemarks = (this.pc.Partial this.astNode #TagType (this.pc.Map (this.pc.Join (this.pc.Sequence #(this.tagTypeSymbol(), this.pc.Token "remarks"););) this.asName;);),private fn tagTypeReturns = (this.pc.Partial this.astNode #TagType (this.pc.Map (this.pc.Join (this.pc.Sequence #(this.tagTypeSymbol(), this.pc.Token "returns"););) this.asName;);),private fn tagTypeVar = (this.pc.Partial this.astNode #TagType (this.pc.Map (this.pc.Join (this.pc.Sequence #(this.tagTypeSymbol(), this.pc.Token "var"););) this.asName;);),private fn tagTypeSymbol = (this.pc.Skip (this.pc.Char "@");),private fn start = (this.pc.Token "/*-";),private fn end = (this.pc.Token "*/";),private fn identifier = (this.pc.Join (this.pc.Sequence #(this.pc.Choice #(this.letter(),this.pc.Char "_";),this.pc.Many (this.pc.Choice #(this.alphanumeric(),this.pc.Char "_";););););),private fn quotedName = (this.pc.Join (this.pc.Sequence #(this.pc.Char "'",this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.pc.Char "'"),this.pc.AnyChar(););),this.pc.Expect (this.pc.Char "'") expected:"'";););),private fn alphanumeric = (this.pc.Choice #(this.letter(), this.digit());),private fn digit = (this.pc.Digit();),private fn letter = (this.pc.Alphabet();),private fn whitespace = (this.pc.Skip (this.pc.Many (this.pc.Choice #(this.space(),this.newLine(););););),private fn space = (this.pc.Char " \t";),private fn newLine = (this.pc.Char "\n";),private fn asName result = (if classOf result == String then (result as Name;);else (::FailureStruct(););),private fn astNode type result = (case classOf result of ((::FailureStruct): result;(::NotCollectStruct): result;default: (if classOf result == Array and result.Count == 0 then (::NotCollectStruct(););else (::AstNodeStruct Type:type Value:result;);););),private fn trimText result = (if classOf result == String then (result = ::std.StringUtility.Trim result;if result.Count == 0 then (::NotCollectStruct(););else (result;););else (::FailureStruct(););),public fn StructName = #DocCommentStruct,public fn Dump indent:"" out:listener = (format "%DocCommentStruct\n" indent to:out;format "%  ShowError:%\n" indent this.ShowError to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (local pathUtility = ::std.PathUtilityStruct (getSourceFileName());this.pc = ::ParserCombinatorStruct();this.parser = this.program();););::docGeneratorDefinitionPool[@"Parser\PathNameLiteral.ms"] = struct PathNameLiteralStruct (public ShowError = false,private parser,private pc,public fn GetParser = (this.parser;),public fn Parse input = (local context = this.pc.Context input;local result = this.parser.Parse context;if this.ShowError do context.PrintError result;result;),private fn pathNameLiteral = (this.pc.Join (this.pc.Sequence #(this.pc.Char "$",this.pc.Option (this.path());););),private fn path = (this.pc.Sequence #(this.pc.Option (this.objectset()),this.pc.Option (this.pc.Char "/"),this.pc.Option (this.levels()),this.level(););),private fn levels = (this.pc.Join (this.pc.Sequence #(this.level(),this.pc.Many (this.pc.Sequence #(this.pc.Choice #(this.pc.Char "/",this.pc.Token "...";),this.level();););););),private fn level = (this.pc.Join (this.pc.Choice #(this.pc.Sequence #(this.pc.Char "'",this.pc.Many (this.pc.Choice #(this.pc.AndAlso #(this.pc.IsNot (this.pc.Char "'"),this.pc.AnyChar();),this.pc.Token "\\*",this.pc.Token "\\?",this.pc.Token "\\\\";);),this.pc.Expect (this.pc.Char "'") expected:"'";),this.pc.Many (this.pc.Choice #(this.alphanumeric(),this.pc.Char "_*?\\";);),this.pc.Token "...";););),private fn objectset = (this.pc.Choice #(this.pc.Token "cameras",this.pc.Token "geometry",this.pc.Token "helpers",this.pc.Token "lights",this.pc.Token "objects",this.pc.Token "selection",this.pc.Token "shapes",this.pc.Token "spacewarps",this.pc.Token "systems";);),private fn alphanumeric = (this.pc.Choice #(this.letter(), this.digit());),private fn digit = (this.pc.Digit();),private fn letter = (this.pc.Alphabet();),public fn StructName = #PathNameLiteralStruct,public fn Dump indent:"" out:listener = (format "%PathNameLiteralStruct\n" indent to:out;format "%  ShowError:%\n" indent this.ShowError to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (local pathUtility = ::std.PathUtilityStruct (getSourceFileName());this.pc = ::ParserCombinatorStruct();this.parser = this.pathNameLiteral();););::docGeneratorDefinitionPool[@"Parser\StringLiteral.ms"] = struct StringLiteralStruct (public ShowError = false,private parser,private pc,public fn GetParser = (this.parser;),public fn Parse input = (local context = this.pc.Context input;local result = this.parser.Parse context;if this.ShowError do context.PrintError result;result;),private fn stringLiteral = (this.pc.Join (this.pc.Choice #(this.pc.Sequence #(this.pc.Token "@\"",this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.pc.Char "\""),this.pc.AnyChar(););),this.pc.Expect (this.pc.Char "\"") expected:"\"";),this.pc.Sequence #(this.pc.Char "\"",this.pc.Many (this.pc.Choice #(this.escapeSeq(),this.pc.AndAlso #(this.pc.IsNot (this.pc.Char "\""),this.pc.AnyChar();););),this.pc.Expect (this.pc.Char "\"") expected:"\"";);););),private fn escapeSeq = (this.pc.Choice #(this.pc.Token "\\\"",this.pc.Token "\\n",this.pc.Token "\\r",this.pc.Token "\\t",this.pc.Token "\\*",this.pc.Token "\\?",this.pc.Token "\\\\",this.pc.Token "\\%",this.pc.Sequence #(this.pc.Char "\\x",this.hexDigits();););),private fn hexDigits = (this.pc.Many (this.hexDigit()) minCount:1;),private fn hexDigit = (this.pc.Char "abcdefABCDEF0123456789";),public fn StructName = #StringLiteralStruct,public fn Dump indent:"" out:listener = (format "%StringLiteralStruct\n" indent to:out;format "%  ShowError:%\n" indent this.ShowError to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (local pathUtility = ::std.PathUtilityStruct (getSourceFileName());this.pc = ::ParserCombinatorStruct();this.parser = this.stringLiteral();););::docGeneratorDefinitionPool[@"Parser\DocDependent.ms"] = struct DocDependentStruct (public ShowError = false,private parser,private pc,private pathNameLiteralParser,private stringLiteralParser,public fn GetParser = (this.parser;),public fn Parse input = (local context = this.pc.Context input;local result = this.parser.Parse context;if this.ShowError do context.PrintError result;result;),private fn program = (this.pc.Partial this.astNode #DocDependent (this.rootGlobal(););),private fn rootGlobal = (this.pc.Flatten (this.pc.Many (this.pc.Sequence #(this.pc.Option (this.rootDelimiter()),this.pc.Choice #(this.structDecl(),this.globalVarDecl(),this.globalVarName(),this.exprSeq();););););),private fn nonRootGlobal = (this.pc.Flatten (this.pc.Many (this.pc.Sequence #(this.pc.Option (this.nonRootDelimiter()),this.pc.Choice #(this.globalVarDecl(),this.globalVarName(),this.exprSeq();););););),private fn exprSeq = (this.pc.Flatten (this.pc.Sequence #(this.pc.Skip (this.pc.Char "("),this.pc.Option (this.pc.Delay this.nonRootGlobal;),this.pc.Option (this.nonRootDelimiter()),this.pc.Expect (this.pc.Skip (this.pc.Char ")")) expected:")";););),private fn rootDelimiter = (this.pc.Skip (this.pc.Many (this.pc.Choice #(this.delimitedLiteral(),this.pc.AndAlso #(this.pc.IsNot (this.pc.Choice #(this.structStart(),this.globalStart(),this.globalSymbol(),this.pc.Char "(",this.pc.Char ")";);),this.pc.AnyChar();););););),private fn nonRootDelimiter = (this.pc.Skip (this.pc.Many (this.pc.Choice #(this.delimitedLiteral(),this.pc.AndAlso #(this.pc.IsNot (this.pc.Choice #(this.globalStart(),this.globalSymbol(),this.pc.Char "(",this.pc.Char ")";);),this.pc.AnyChar();););););),private fn delimitedLiteral = (this.pc.Choice #(this.pathNameLiteral(),this.blockComment(),this.singleLineComment(),this.stringLiteral(););),private fn structDecl = (this.pc.Partial this.astNode #StructDecl (this.pc.ItemAt (this.pc.Sequence #(this.pc.Skip (this.structStart()),this.whitespace(),this.varName(););) -1;);),private fn globalVarDecl = (this.pc.Partial this.astNode #GlobalVarDecl (this.pc.ItemAt (this.pc.Sequence #(this.pc.Skip (this.globalStart()),this.whitespace(),this.varName(););) -1;);),private fn structStart = (this.pc.ItemAt (this.pc.Sequence #(this.pc.Skip (this.pc.Boundary()),this.pc.Token "struct",this.pc.Skip (this.pc.Boundary()););) -1;),private fn globalStart = (this.pc.ItemAt (this.pc.Sequence #(this.pc.Skip (this.pc.Boundary()),this.pc.Token "global",this.pc.Skip (this.pc.Boundary()););) -1;),private fn globalVarName = (this.pc.Partial this.astNode #GlobalVarName (this.pc.Join (this.pc.Sequence #(this.pc.Skip (this.globalSymbol()),this.pc.Choice #(this.pc.Sequence #(this.keyword(),this.identifier();),this.pc.AndAlso #(this.pc.IsNot (this.keyword()),this.identifier();),this.quotedName();););););),private fn varName = (this.pc.Partial this.astNode #VarName (this.pc.Join (this.pc.Sequence #(this.pc.Skip (this.pc.Option (this.globalSymbol())),this.pc.Choice #(this.pc.Sequence #(this.keyword(),this.identifier();),this.pc.AndAlso #(this.pc.IsNot (this.keyword()),this.identifier();),this.quotedName();););););),private fn globalSymbol = (this.pc.Token "::";),private fn blockComment = (this.pc.Sequence #(this.pc.Token "/*",this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.pc.Token "*/"),this.pc.AnyChar(););),this.pc.Expect (this.pc.Token "*/") expected:"*/";);),private fn singleLineComment = (this.pc.Sequence #(this.pc.Token "--",this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.newLine()),this.pc.AnyChar(););););),private fn stringLiteral = (this.stringLiteralParser.GetParser();),private fn pathNameLiteral = (this.pathNameLiteralParser.GetParser();),private fn identifier = (this.pc.Join (this.pc.Sequence #(this.pc.Choice #(this.letter(),this.pc.Char "_";),this.pc.Many (this.pc.Choice #(this.alphanumeric(),this.pc.Char "_";););););),private fn quotedName = (this.pc.Join (this.pc.Sequence #(this.pc.Char "'",this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.pc.Char "'"),this.pc.AnyChar(););),this.pc.Expect (this.pc.Char "'") expected:"'";););),private fn alphanumeric = (this.pc.Choice #(this.letter(), this.digit());),private fn digit = (this.pc.Digit();),private fn letter = (this.pc.Alphabet();),private fn whitespace = (this.pc.Skip (this.pc.Many (this.pc.Choice #(this.continuation(),this.space(),this.newLine(););););),private fn continuation = (this.pc.Sequence #(this.pc.Char "\\",this.pc.Many (this.space),this.newLine(););),private fn space = (this.pc.Char " \t";),private fn newLine = (this.pc.Char "\n";),private fn keyword = (this.pc.Choice #(this.pc.Token "about",this.pc.Token "and",this.pc.Token "animate",this.pc.Token "as",this.pc.Token "at",this.pc.Token "attributes",this.pc.Token "by",this.pc.Token "case",this.pc.Token "catch",this.pc.Token "collect",this.pc.Token "continue",this.pc.Token "coordsys",this.pc.Token "do",this.pc.Token "else",this.pc.Token "exit",this.pc.Token "fn",this.pc.Token "for",this.pc.Token "from",this.pc.Token "function",this.pc.Token "global",this.pc.Token "if",this.pc.Token "in",this.pc.Token "local",this.pc.Token "macroscript",this.pc.Token "mapped",this.pc.Token "max",this.pc.Token "not",this.pc.Token "of",this.pc.Token "off",this.pc.Token "on",this.pc.Token "or",this.pc.Token "parameters",this.pc.Token "persistent",this.pc.Token "plugin",this.pc.Token "private",this.pc.Token "public",this.pc.Token "rcmenu",this.pc.Token "return",this.pc.Token "rollout",this.pc.Token "set",this.pc.Token "struct",this.pc.Token "then",this.pc.Token "throw",this.pc.Token "to",this.pc.Token "tool",this.pc.Token "try",this.pc.Token "undo",this.pc.Token "utility",this.pc.Token "when",this.pc.Token "where",this.pc.Token "while",this.pc.Token "with";);),private fn astNode type result = (case classOf result of ((::FailureStruct): result;(::NotCollectStruct): result;default: (if classOf result == Array and result.Count == 0 then (::NotCollectStruct(););else (::AstNodeStruct Type:type Value:result;);););),public fn StructName = #DocDependentStruct,public fn Dump indent:"" out:listener = (format "%DocDependentStruct\n" indent to:out;format "%  ShowError:%\n" indent this.ShowError to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (local pathUtility = ::std.PathUtilityStruct (getSourceFileName());this.pc = ::ParserCombinatorStruct();this.pathNameLiteralParser = (::docGeneratorDefinitionPool[@"Parser\PathNameLiteral.ms"]) ShowError:this.ShowError;this.stringLiteralParser = (::docGeneratorDefinitionPool[@"Parser\StringLiteral.ms"]) ShowError:this.ShowError;this.parser = this.program();););::docGeneratorDefinitionPool[@"Parser\Doc.ms"] = struct DocStruct (public ShowError = false,private parser,private pc,private docCommentParser,private pathNameLiteralParser,private stringLiteralParser,public fn GetParser = (this.parser;),public fn Parse input = (local context = this.pc.Context input;local result = this.parser.Parse context;if this.ShowError do context.PrintError result;result;),private fn program = (this.pc.Partial this.astNode #Document (this.pc.Flatten (this.pc.Sequence #(this.docDelimiter(),this.pc.Option (this.docs()););) depth:1;);),private fn docs = (this.pc.Flatten (this.pc.Many (this.pc.Sequence #(this.doc(),this.docDelimiter(););) minCount:1;) depth:1;),private fn doc = (this.pc.Choice #(this.simpleDoc(),this.docSeq(););),private fn simpleDoc = (this.pc.Partial this.astNode #SimpleDoc (this.pc.Sequence #(this.docComment(),this.keywordDelimiter(),this.pc.Option (this.keywords()),this.pc.Expect (this.varName()) expected:"<var_name>";););),private fn docSeq = (this.pc.Partial this.astNode #DocSeq (this.pc.Flatten (this.pc.Sequence #(this.pc.Skip (this.pc.Char "("),this.docDelimiter(),this.pc.Option (this.pc.Delay this.docs;),this.pc.Expect (this.pc.Skip (this.pc.Char ")")) expected:")";);) depth:1;);),private fn keywords = (this.pc.Partial this.astNode #Keywords (this.pc.Flatten (this.pc.Many (this.pc.Partial this.astNode #Keyword (this.pc.Join (this.pc.Sequence #(this.pc.Lookahead #(this.keyword(),this.pc.IsNot (this.identifier());),this.keywordDelimiter(););););) minCount:1;) depth:1;);),private fn docDelimiter = (this.pc.Skip (this.pc.Many (this.pc.Choice #(this.delimitedLiteral(),this.pc.AndAlso #(this.pc.IsNot (this.pc.Choice #(this.docCommentStart(),this.pc.Char "(",this.pc.Char ")";);),this.pc.AnyChar();););););),private fn keywordDelimiter = (this.pc.Skip (this.pc.Many (this.pc.Choice #(this.delimitedLiteral(),this.pc.AndAlso #(this.pc.IsNot (this.pc.Choice #(this.keyword(),this.varName(););),this.pc.AnyChar();););););),private fn delimitedLiteral = (this.pc.Choice #(this.pathNameLiteral(),this.delimitedComment(),this.singleLineComment(),this.stringLiteral(););),private fn varName = (this.pc.Partial this.astNode #VarName (this.pc.Join (this.pc.Sequence #(this.pc.Option (this.pc.Token "::"),this.pc.Choice #(this.pc.Sequence #(this.keyword(),this.identifier();),this.pc.AndAlso #(this.pc.IsNot (this.keyword()),this.identifier();),this.quotedName();););););),private fn docComment = (this.docCommentParser.GetParser();),private fn delimitedComment = (this.pc.Sequence #(this.pc.Lookahead #(this.pc.Token "/*",this.pc.IsNot (this.pc.Char "-");),this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.docCommentEnd()),this.pc.AnyChar(););),this.pc.Expect (this.docCommentEnd()) expected:"*/";);),private fn singleLineComment = (this.pc.Sequence #(this.pc.Token "--",this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.newLine()),this.pc.AnyChar(););););),private fn docCommentStart = (this.pc.Token "/*-";),private fn docCommentEnd = (this.pc.Token "*/";),private fn stringLiteral = (this.stringLiteralParser.GetParser();),private fn pathNameLiteral = (this.pathNameLiteralParser.GetParser();),private fn identifier = (this.pc.Join (this.pc.Sequence #(this.pc.Choice #(this.letter(),this.pc.Char "_";),this.pc.Many (this.pc.Choice #(this.alphanumeric(),this.pc.Char "_";););););),private fn quotedName = (this.pc.Join (this.pc.Sequence #(this.pc.Char "'",this.pc.Many (this.pc.AndAlso #(this.pc.IsNot (this.pc.Char "'"),this.pc.AnyChar(););),this.pc.Expect (this.pc.Char "'") expected:"'";););),private fn alphanumeric = (this.pc.Choice #(this.letter(), this.digit());),private fn digit = (this.pc.Digit();),private fn letter = (this.pc.Alphabet();),private fn whitespace = (this.pc.Skip (this.pc.Many (this.pc.Choice #(this.continuation(),this.space(),this.newLine(););););),private fn continuation = (this.pc.Sequence #(this.pc.Char "\\",this.pc.Many (this.space),this.newLine(););),private fn space = (this.pc.Char " \t";),private fn newLine = (this.pc.Char "\n";),private fn keyword = (this.pc.Choice #(this.pc.Token "about",this.pc.Token "and",this.pc.Token "animate",this.pc.Token "as",this.pc.Token "attributes",this.pc.Token "at",this.pc.Token "by",this.pc.Token "case",this.pc.Token "catch",this.pc.Token "collect",this.pc.Token "continue",this.pc.Token "coordsys",this.pc.Token "do",this.pc.Token "else",this.pc.Token "exit",this.pc.Token "fn",this.pc.Token "for",this.pc.Token "from",this.pc.Token "function",this.pc.Token "global",this.pc.Token "if",this.pc.Token "in",this.pc.Token "local",this.pc.Token "macroscript",this.pc.Token "mapped",this.pc.Token "max",this.pc.Token "not",this.pc.Token "off",this.pc.Token "of",this.pc.Token "on",this.pc.Token "or",this.pc.Token "parameters",this.pc.Token "persistent",this.pc.Token "plugin",this.pc.Token "private",this.pc.Token "public",this.pc.Token "rcmenu",this.pc.Token "return",this.pc.Token "rollout",this.pc.Token "set",this.pc.Token "struct",this.pc.Token "then",this.pc.Token "throw",this.pc.Token "tool",this.pc.Token "to",this.pc.Token "try",this.pc.Token "undo",this.pc.Token "utility",this.pc.Token "when",this.pc.Token "where",this.pc.Token "while",this.pc.Token "with";);),private fn astNode type result = (case classOf result of ((::FailureStruct): result;(::NotCollectStruct): result;default: (if classOf result == Array and result.Count == 0 then (::NotCollectStruct(););else (::AstNodeStruct Type:type Value:result;);););),public fn StructName = #DocStruct,public fn Dump indent:"" out:listener = (format "%DocStruct\n" indent to:out;format "%  ShowError:%\n" indent this.ShowError to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (local pathUtility = ::std.PathUtilityStruct (getSourceFileName());this.pc = ::ParserCombinatorStruct();this.docCommentParser = (::docGeneratorDefinitionPool[@"Parser\DocComment.ms"]) ShowError:this.ShowError;this.pathNameLiteralParser = (::docGeneratorDefinitionPool[@"Parser\PathNameLiteral.ms"]) ShowError:this.ShowError;this.stringLiteralParser = (::docGeneratorDefinitionPool[@"Parser\StringLiteral.ms"]) ShowError:this.ShowError;this.parser = this.program();););struct DocGeneratorStruct (public Options,private docDependentParser,private docDependentTable,private docParser,private docRender,private pathMaker,private pathUtility,public fn FromDirectory dir recursive:false ignore: exception: = (this.docDependentTable.Initialize();local paths = this.pathMaker.FromDirectory dir recursive:recursive ignore:ignore exception:exception;for path in paths do (this.extractDependent path;);for path in paths do (this.convertFile path;);ok;),public fn FromFile file = (this.docDependentTable.Initialize();local path = this.pathMaker.FromFile file;this.extractDependent path;this.convertFile path;ok;),public fn IndexFromDirectory dir recursive:false ignore: exception: = (local absBasePath = this.pathMaker.GetAbsoluteBasePath();local paths = this.pathMaker.FromDirectory dir recursive:recursive ignore:ignore exception:exception;local pathTree = this.makePathTree absBasePath paths;local html = this.pathTreeToHtml pathTree;local content = this.docRender.RenderIndex html;local indexPath = this.pathMaker.GetAbsoluteIndexPath();local destDirPath = this.pathUtility.GetDirectoryName indexPath;if not ::std.FileUtility.DirectoryExists destDirPath do (::std.FileUtility.CreateDirectory destDirPath;);if ::std.FileUtility.DirectoryExists destDirPath do (::std.FileUtility.WriteAllText indexPath content;);ok;),private fn convertFile path = (local code = ::std.FileUtility.ReadAllText path.Source encoding:this.Options.EncodingName bom:this.Options.EncodingBom;local docTitle = this.pathUtility.GetFileName path.Source;local astNode = this.docParser.Parse code;local dependent = this.docDependentTable.GetDependent path;local content = this.docRender.Render astNode docTitle:docTitle dependent:dependent;local destDirPath = this.pathUtility.GetDirectoryName path.Destination;if not ::std.FileUtility.DirectoryExists destDirPath do (::std.FileUtility.CreateDirectory destDirPath;);if ::std.FileUtility.DirectoryExists destDirPath do (::std.FileUtility.WriteAllText path.Destination content;);ok;),private fn compareFileName a b = (local aWeight = (this.pathUtility.HasExtension a.Name) as Integer;local bWeight = (this.pathUtility.HasExtension b.Name) as Integer;case of ((aWeight < bWeight): -1;(aWeight > bWeight): 1;default: ::std.Comparer.CompareName a b;);),private fn dumpPathTree pathTree indent = (for path in pathTree do (if classOf path.Value == Array then (format "%%\n" indent path.Name;this.dumpPathTree path.Value (indent + "  "););else (local fileName = this.pathUtility.GetFileName path.Value.Destination;format "%% - %\n" indent path.Name fileName;););ok;),private fn extractDependent path = (local code = ::std.FileUtility.ReadAllText path.Source encoding:this.Options.EncodingName bom:this.Options.EncodingBom;local astNode = this.docDependentParser.Parse code;this.docDependentTable.AddDependent astNode path;ok;),private fn isDocOptions obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #DocOptionsStruct;),private fn makePathTree parentPath paths = (local fileNames = #();local subPaths = #();for path in paths do (local lowPath = substituteString path.Source parentPath "";local components = ::std.StringUtility.Split lowPath @"\";if components.Count > 0 do (local firstComponent = components[1];deleteItem components 1;local index = findItem fileNames firstComponent;if index == 0 then (append fileNames firstComponent;append subPaths (DataPair Name:firstComponent Value:#(path));index = subPaths.Count;);else (append subPaths[index].Value path;);););if paths.Count == 1 and subPaths.Count == 0 then (paths[1];);else (qsort subPaths this.compareFileName;for subPath in subPaths do (local nextParentPath = parentPath + @"\" + subPath.Name;subPath.Value = this.makePathTree nextParentPath subPath.Value;);subPaths;);),private fn pathTreeToHtml pathTree = (local html = StringStream "";format "<ul>\n" to:html;for path in pathTree do (if classOf path.Value == Array then (format "<li><p>%</p>%</li>\n" path.Name (this.pathTreeToHtml path.Value) to:html;);else (format "<li><p><a href=\"%\">%</a></p></li>\n" (this.pathUtility.GetFileName path.Value.Destination) path.Name to:html;););format "</ul>" to:html;html as String;),private version = "1.1.2",public fn StructName = #DocGeneratorStruct,public fn Dump indent:"" out:listener = (format "%DocGeneratorStruct\n" indent to:out;format "%  pathMaker:\n" indent to:out;this.pathMaker.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),public fn GetVersion = (this.version;),on Create do (if not this.isDocOptions this.Options do (this.Options = (::docGeneratorDefinitionPool[@"DocOptions.ms"])(););this.docDependentParser = (::docGeneratorDefinitionPool[@"Parser\DocDependent.ms"]) ShowError:this.Options.ShowError;this.docDependentTable = (::docGeneratorDefinitionPool[@"DocDependentTable.ms"])();this.docParser = (::docGeneratorDefinitionPool[@"Parser\Doc.ms"]) ShowError:this.Options.ShowError;this.docRender = (::docGeneratorDefinitionPool[@"DocRender.ms"]) this.Options;this.pathMaker = (::docGeneratorDefinitionPool[@"DocPathMaker.ms"]) this.Options;this.pathUtility = ::std.PathUtilityStruct (getSourceFileName());););
